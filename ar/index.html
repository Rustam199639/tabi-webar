<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>TABI Agent AR Arrows</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js" crossorigin="anonymous"></script>

  <!-- Robust THREE shim so AR.js (built for older THREE) works with A-Frame 1.4.x -->
  <script>
    (function fixThreeForARJS(){
      function apply(){
        try{
          var A = window.AFRAME;
          if (!A || !A.THREE) return false;

          // AR.js reads from window.THREE → bind it to A-Frame’s THREE
          if (!window.THREE) window.THREE = A.THREE;

          var T = window.THREE;
          if (!T.Math) T.Math = {};

          var MU = T.MathUtils || (A.THREE && A.THREE.MathUtils);
          if (!T.Math.degToRad) T.Math.degToRad = MU && MU.degToRad ? MU.degToRad : function(d){ return d * Math.PI / 180; };
          if (!T.Math.radToDeg) T.Math.radToDeg = MU && MU.radToDeg ? MU.radToDeg : function(r){ return r * 180 / Math.PI; };
          if (!T.Math.clamp)    T.Math.clamp    = MU && MU.clamp    ? MU.clamp    : function(x,min,max){ return Math.min(Math.max(x,min),max); };

          // Quiet older AR.js geometry alias
          if (!T.PlaneBufferGeometry && T.PlaneGeometry) {
            T.PlaneBufferGeometry = T.PlaneGeometry;
          }
          return true;
        }catch(e){ return false; }
      }
      if (!apply()){
        var tries = 0, id = setInterval(function(){
          if (apply() || ++tries > 80) clearInterval(id);
        }, 50);
        document.addEventListener('DOMContentLoaded', apply, { once: true });
      }
    })();
  </script>

  <!-- AR.js (A-Frame build) -->
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.4/aframe/build/aframe-ar.js" crossorigin="anonymous"></script>

  <!-- Billboard helper (optional for labels etc.) -->
  <script src="https://unpkg.com/aframe-look-at-component@0.8.0/dist/aframe-look-at-component.min.js" crossorigin="anonymous"></script>

  <!-- No-op rotation-reader to avoid missing component errors -->
  <script>
    if (window.AFRAME && !AFRAME.components['rotation-reader']) {
      AFRAME.registerComponent('rotation-reader', { schema:{}, tick:function(){} });
    }
  </script>

  <style>
    html,body{margin:0;padding:0;overflow:hidden;background:#000;font-family:system-ui,-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif}
    .hud{position:fixed;top:8px;left:8px;right:8px;padding:8px 10px;background:rgba(0,0,0,.55);color:#fff;font-size:13px;line-height:18px;border-radius:12px;white-space:pre-line}
  </style>
</head>
<body>
  <div id="hud" class="hud">Loading… allow camera & motion when prompted.</div>

  <a-scene
    vr-mode-ui="enabled:false"
    renderer="colorManagement:true; physicallyCorrectLights:true; logarithmicDepthBuffer:true"
    embedded
    arjs="sourceType: webcam; videoTexture: true; trackingMethod: best; debugUIEnabled: false; facingMode: environment"
  >
    <a-entity light="type: ambient; intensity: 1"></a-entity>

    <!-- IMPORTANT: use projected camera to match projected entities -->
    <a-camera gps-projected-camera rotation-reader></a-camera>

    <a-entity id="layer-arrows"></a-entity>
    <a-entity id="layer-arrival"></a-entity>

    <!-- Debug: big white ring 3 m straight ahead (confirms 3D pipeline) -->
    <a-ring id="debug-forward" position="0 0 -3" rotation="-90 0 0"
            radius-inner="0.4" radius-outer="0.55"
            material="shader:flat; color:#ffffff; opacity:0.95; transparent:true; depthTest:false"></a-ring>
  </a-scene>

  <script>
  (function(){
    // Silence generic cross-origin errors to keep console actionable
    window.addEventListener('error', e => {
      if (e.message === 'Script error.' && !e.filename) { e.preventDefault(); return true; }
    });

    const hud = document.getElementById('hud');
    const arrowsLayer = document.getElementById('layer-arrows');
    const arrivalLayer = document.getElementById('layer-arrival');
    const cameraEl = document.querySelector('[gps-projected-camera]');
    const useProjected = true; // we intentionally use the projected pair

    const log=(...a)=>{try{console.log(...a)}catch{}};
    const warn=(...a)=>{try{console.warn(...a)}catch{}};
    const send=(m)=>{try{window.ReactNativeWebView?.postMessage(JSON.stringify(m))}catch{}};

    log('[AR] DOM ok. useProjected =', useProjected);

    // Math helpers
    const toRad = d => d*Math.PI/180;
    function dMeters(a,b){
      const R=6371000, dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng), lat1=toRad(a.lat), lat2=toRad(b.lat);
      const hav = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLng/2)**2;
      return 2*R*Math.atan2(Math.sqrt(hav), Math.sqrt(1-hav));
    }

    // DOM helpers
    function clear(el){ if (!el) return; while(el.firstChild) el.removeChild(el.firstChild); }
    function disableCulling(root){ try{ root.object3D.traverse(o=>{ o.frustumCulled = false; }); }catch{} }
    function placeAtLatLng(node, lat, lng){
      node.setAttribute('gps-projected-entity-place', `latitude: ${lat}; longitude: ${lng}`);
    }

    // Big scale so arrows are obvious
    function scaleFor(distance){
      const s = Math.max(10, Math.min(32, 10 + (distance/4))); // 0m=>10x, 20m=>15x, 80m=>30x
      return `${s} ${s} ${s}`;
    }

    // Directional arrow — keep yaw (do NOT face the camera)
    function makeArrow(yawDeg, approxDistance){
      const wrap = document.createElement('a-entity');
      wrap.setAttribute('rotation', `0 ${yawDeg} 0`);
      wrap.setAttribute('position', '0 10 0');
      wrap.setAttribute('scale', scaleFor(approxDistance || 20));

      const shaft = document.createElement('a-cylinder');
      shaft.setAttribute('height','6.0');
      shaft.setAttribute('radius','0.25');
      shaft.setAttribute('position','0 3 0');
      shaft.setAttribute('material','shader: flat; color: #00E0FF; opacity:0.99; transparent:true; depthTest:false; side:double; emissive:#00E0FF; emissiveIntensity:1.5');

      const head = document.createElement('a-cone');
      head.setAttribute('height','2.2');
      head.setAttribute('radius-bottom','0.7');
      head.setAttribute('radius-top','0.01');
      head.setAttribute('position','0 5.3 0');
      head.setAttribute('material','shader: flat; color: #00E0FF; opacity:0.99; transparent:true; depthTest:false; side:double; emissive:#00E0FF; emissiveIntensity:1.6');

      wrap.appendChild(shaft);
      wrap.appendChild(head);
      disableCulling(wrap);
      return wrap;
    }

    function makeDebugSphere(color='#ff0000'){
      const s = document.createElement('a-sphere');
      s.setAttribute('radius','2.0');
      s.setAttribute('position','0 10 0');
      s.setAttribute('material',`shader: flat; color:${color}; opacity:0.6; transparent:true; depthTest:false; side:double; emissive:${color}; emissiveIntensity:1.0`);
      // Billboarding helps spot the marker head-on if you want (optional):
      s.setAttribute('look-at', '[gps-projected-camera]');
      disableCulling(s);
      return s;
    }

    // State
    let anchors = [];       // [{lat,lng,yaw}]
    let activeIndex = 0;
    let arrived = false;
    let here = null;        // {lat,lng} from watchPosition

    function updateHUD(dist){
      if (!anchors.length){ hud.textContent='Waiting for anchors…'; return; }
      if (arrived){ hud.textContent='Arrived — look around for the destination.'; return; }
      const next = anchors[activeIndex];
      const label = `${activeIndex+1}/${anchors.length}`;
      const dt = (typeof dist==='number') ? `${Math.max(0,Math.round(dist))} m` : '…';
      hud.textContent = `Next: ${label} — ${dt}${next?`\n(${next.lat.toFixed(5)}, ${next.lng.toFixed(5)})`:''}`;
    }

    function renderArrows(){
      clear(arrivalLayer); clear(arrowsLayer);
      if (!anchors.length || arrived) return;

      const toShow = [activeIndex, activeIndex+1].filter(i => i < anchors.length);
      log('[AR] render arrows', toShow.length, 'active', activeIndex);
      send({ type:'arrows_rendered', count: toShow.length, active: activeIndex });

      toShow.forEach((idx,i) => {
        const a = anchors[idx];
        const node = document.createElement('a-entity');
        placeAtLatLng(node, a.lat, a.lng);

        // debug spheres: red=current, orange=next
        node.appendChild(makeDebugSphere(i===0 ? '#ff0000' : '#ffa500'));

        const approx = here ? dMeters(here, a) : 20;
        node.appendChild(makeArrow(a.yaw, approx));

        disableCulling(node);
        arrowsLayer.appendChild(node);
      });
    }

    function showArrival(){
      arrived = true;
      clear(arrowsLayer); clear(arrivalLayer);
      const last = anchors[anchors.length-1]; if (!last) return;

      const wrap = document.createElement('a-entity');
      placeAtLatLng(wrap, last.lat, last.lng);
      const ring = document.createElement('a-ring');
      ring.setAttribute('radius-inner','1.2');
      ring.setAttribute('radius-outer','1.6');
      ring.setAttribute('rotation','-90 0 0');
      ring.setAttribute('position','0 0.1 0');
      ring.setAttribute('material','shader: flat; color:#10B981; opacity:0.99; transparent:true; depthTest:false; side:double; emissive:#10B981; emissiveIntensity:1.5');
      wrap.appendChild(ring);
      disableCulling(wrap);
      arrivalLayer.appendChild(wrap);

      hud.textContent = 'Arrived — look around for the destination.';
      send({ type:'arrived' });
    }

    function setAnchors(data){
      anchors = Array.isArray(data) ? data : [];
      activeIndex = 0; arrived = false;
      log('[AR] anchors received', anchors.length);
      send({ type:'anchors_received', count: anchors.length });
      renderArrows(); updateHUD(undefined);
    }

    function onMsg(ev){
      try{
        const p = JSON.parse(ev.data);
        if (p?.type === 'anchors') setAnchors(p.data);
      }catch(err){ warn('[AR] invalid message', err); }
    }
    document.addEventListener('message', onMsg);
    window.addEventListener('message', onMsg);

    // Keep our own live position for HUD + advancing logic
    let watchId = null;
    function startWatch(){
      if (watchId !== null) return;
      try{
        watchId = navigator.geolocation.watchPosition(
          pos => {
            here = { lat: pos.coords.latitude, lng: pos.coords.longitude };
            send({ type:'geo_ok', lat: here.lat, lng: here.lng });

            if (anchors.length && !arrived) {
              const target = anchors[activeIndex];
              const dist = dMeters(here, target);
              updateHUD(dist);

              // keep shown groups large and visible + re-scale with distance
              try {
                const groups = arrowsLayer.children || [];
                for (let i=0;i<groups.length;i++){
                  const group = groups[i];
                  group.setAttribute('scale', scaleFor(dist));
                  disableCulling(group);
                }
              } catch {}

              if (activeIndex < anchors.length-1 && dist <= 8){
                activeIndex += 1; renderArrows(); updateHUD(dMeters(here, anchors[activeIndex]));
                log('[AR] advance to', activeIndex); send({ type:'advance', idx: activeIndex });
              } else if (activeIndex === anchors.length-1 && dist <= 25 && !arrived){
                showArrival();
              }
            }
          },
          err => {
            warn('[AR] watchPosition error', err?.code, err?.message);
            send({ type:'geo_error', code:err?.code, message:err?.message });
          },
          { enableHighAccuracy:true, timeout:10000, maximumAge:1000, distanceFilter:1 }
        );
      }catch(e){ warn('[AR] watchPosition failed', e); }
    }

    window.addEventListener('load', function(){
      log('[AR] window load'); send({ type:'ready' });
      // Kick a one-shot (helps prompt permission UI on some devices)
      try{
        navigator.geolocation.getCurrentPosition(
          p => { log('[AR] getCurrentPosition ok', p?.coords?.latitude, p?.coords?.longitude); },
          e => { warn('[AR] getCurrentPosition error', e?.code, e?.message); },
          { enableHighAccuracy:true, timeout:10000, maximumAge:1000 }
        );
      }catch(e){ warn('[AR] geolocation call failed', e); }
      startWatch();
    });

    // (Optional) If AR.js exposes origin event, re-render when it’s ready
    ['gps-camera-origin-coord','gps-projected-camera-origin-coord','gps-camera-update-position'].forEach(evt=>{
      cameraEl && cameraEl.addEventListener(evt, () => { log('[AR] camera event:', evt); renderArrows(); });
    });
  })();
  </script>
</body>
</html>
