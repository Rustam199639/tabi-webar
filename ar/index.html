<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>TABI AR — Visible & Minimal</title>

<script src="https://aframe.io/releases/1.4.2/aframe.min.js" crossorigin="anonymous"></script>

<script>
  // Bind AR.js to A-Frame’s THREE (avoids degToRad/radToDeg undefined)
  (function shimTHREE(){
    function apply(){
      try{
        var A=window.AFRAME; if(!A||!A.THREE) return false;
        if(!window.THREE) window.THREE=A.THREE;
        var T=window.THREE; if(!T.Math) T.Math={};
        var MU=T.MathUtils||A.THREE.MathUtils;
        T.Math.degToRad=T.Math.degToRad||((d)=>d*Math.PI/180);
        T.Math.radToDeg=T.Math.radToDeg||((r)=>r*180/Math.PI);
        T.Math.clamp   =T.Math.clamp   ||((x,a,b)=>Math.min(Math.max(x,a),b));
        if(!T.PlaneBufferGeometry && T.PlaneGeometry) T.PlaneBufferGeometry=T.PlaneGeometry;
        return true;
      }catch(e){ return false; }
    }
    if(!apply()){ let n=0; const id=setInterval(()=>{ if(apply()||++n>100) clearInterval(id); },50); }
  })();

  // Always-on-top & no-cull helpers
  if (window.AFRAME) {
    AFRAME.registerComponent('always-on-top', {
      tick(){ this.el.object3D.traverse(o=>{
        o.renderOrder=9999; if(o.material){ o.material.depthTest=false; o.material.depthWrite=false; o.material.needsUpdate=true; }
        o.frustumCulled=false;
      });}
    });
  }
</script>

<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.4/aframe/build/aframe-ar.js" crossorigin="anonymous"></script>

<style>
  html,body{margin:0;padding:0;overflow:hidden;background:#000;}
  /* Put canvas on top, full screen */
  a-scene, .a-canvas, canvas{position:fixed!important;inset:0!important;width:100vw!important;height:100vh!important;z-index:1000000!important;display:block!important;}
  /* Keep DOM HUD above everything */
  .hud{position:fixed;top:8px;left:8px;right:8px;z-index:2147483647;padding:8px 10px;background:rgba(0,0,0,.7);color:#fff;border-radius:12px;font:13px/18px system-ui;white-space:pre-line}
</style>
</head>
<body>
<div id="hud" class="hud">Loading…</div>

<a-scene
  vr-mode-ui="enabled:false"
  renderer="alpha:false; antialias:true; sortObjects:true; preserveDrawingBuffer:true"
  embedded
  arjs="sourceType: webcam; videoTexture: true; trackingMethod: best; debugUIEnabled: false"
>
  <!-- Use NON-projected pair: most compatible -->
  <a-camera gps-camera rotation-reader camera="near:0.01; far:200000"></a-camera>

  <a-entity id="layer-arrows"></a-entity>
  <a-entity id="layer-arrival"></a-entity>

  <!-- LOCAL, non-GPS debug objects (must be visible immediately) -->
  <a-plane position="0 1.5 -2" rotation="-10 0 0" width="2.6" height="1.2"
           material="shader:flat; color:#ff00ff; opacity:0.95; transparent:true"
           always-on-top></a-plane>
  <a-ring position="0 0 -3" rotation="-90 0 0" radius-inner="0.45" radius-outer="0.7"
          material="shader:flat; color:#ffffff; opacity:0.95; transparent:true"
          always-on-top></a-ring>
</a-scene>

<script>
(function(){
  const hud = document.getElementById('hud');
  const arrowsLayer = document.getElementById('layer-arrows');
  const arrivalLayer = document.getElementById('layer-arrival');

  const toRad=d=>d*Math.PI/180;
  function dMeters(a,b){
    const R=6371000, dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng), la1=toRad(a.lat), la2=toRad(b.lat);
    const h=Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLng/2)**2;
    return 2*R*Math.atan2(Math.sqrt(h), Math.sqrt(1-h));
  }
  function clear(el){ while(el.firstChild) el.removeChild(el.firstChild); }
  function placeAtLatLng(node, lat, lng){ node.setAttribute('gps-entity-place',`latitude:${lat}; longitude:${lng}`); }

  function scaleFor(distance){ const s = Math.max(30, Math.min(80, 24 + distance/2)); return `${s} ${s} ${s}`; }

  function makeArrow(yawDeg, approx){
    const wrap=document.createElement('a-entity');
    wrap.setAttribute('rotation',`0 ${yawDeg||0} 0`);
    wrap.setAttribute('position','0 2 0');                 // ~eye height
    wrap.setAttribute('scale',scaleFor(approx||30));
    wrap.setAttribute('always-on-top','');

    // BRIGHT, light-independent, FLAT shader (no emissive, no lights required)
    const shaft=document.createElement('a-cylinder');
    shaft.setAttribute('height','6'); shaft.setAttribute('radius','0.4'); shaft.setAttribute('position','0 3 0');
    shaft.setAttribute('material','shader:flat; color:#00e0ff; opacity:1; transparent:true');

    const head=document.createElement('a-cone');
    head.setAttribute('height','2.8'); head.setAttribute('radius-bottom','1.2'); head.setAttribute('radius-top','0.01'); head.setAttribute('position','0 5.6 0');
    head.setAttribute('material','shader:flat; color:#00e0ff; opacity:1; transparent:true');

    wrap.appendChild(shaft); wrap.appendChild(head);
    return wrap;
  }

  // State
  let anchors=[]; let activeIndex=0; let arrived=false; let here=null;

  function updateHUD(dist){
    if (!anchors.length){ hud.textContent='Waiting for anchors…'; return; }
    if (arrived){ hud.textContent='Arrived — look around for the destination.'; return; }
    const next=anchors[activeIndex];
    const label=`${activeIndex+1}/${anchors.length}`;
    const dt=(typeof dist==='number')?`${Math.round(Math.max(0,dist))} m`:'…';
    hud.textContent=`Next: ${label} — ${dt}${next?`\n(${next.lat.toFixed(5)}, ${next.lng.toFixed(5)})`:''}`;
  }

  function renderArrows(){
    clear(arrivalLayer); clear(arrowsLayer);
    if(!anchors.length || arrived) return;
    const toShow=[activeIndex, activeIndex+1].filter(i=>i<anchors.length);
    let approx = here && anchors[activeIndex] ? dMeters(here, anchors[activeIndex]) : 30;

    toShow.forEach((idx,i)=>{
      const a=anchors[idx];
      const n=document.createElement('a-entity');
      placeAtLatLng(n, a.lat, a.lng);
      const lbl=document.createElement('a-entity');
      lbl.setAttribute('text',`value:${i===0?'NEXT':'→'}; color:${i===0?'#ff4444':'#ffaa00'}; align:center; width:10;`);
      lbl.setAttribute('position','0 3 0');
      lbl.setAttribute('look-at','[gps-camera]');
      lbl.setAttribute('always-on-top','');
      n.appendChild(lbl);

      n.appendChild(makeArrow(a.yaw, approx||30));
      arrowsLayer.appendChild(n);
    });
  }

  function showArrival(){
    arrived=true; clear(arrowsLayer); clear(arrivalLayer);
    const last=anchors[anchors.length-1]; if(!last) return;
    const w=document.createElement('a-entity'); placeAtLatLng(w,last.lat,last.lng);
    const r=document.createElement('a-ring'); r.setAttribute('radius-inner','2'); r.setAttribute('radius-outer','2.6'); r.setAttribute('rotation','-90 0 0'); r.setAttribute('position','0 0.2 0');
    r.setAttribute('material','shader:flat; color:#10b981; opacity:1; transparent:true'); r.setAttribute('always-on-top','');
    const t=document.createElement('a-entity'); t.setAttribute('text','value:ARRIVED; color:#10b981; align:center; width:10;'); t.setAttribute('position','0 2 0'); t.setAttribute('look-at','[gps-camera]'); t.setAttribute('always-on-top','');
    w.appendChild(r); w.appendChild(t); arrivalLayer.appendChild(w);
    hud.textContent='Arrived — look around for the destination.';
  }

  // RN bridge
  function setAnchors(data){
    anchors = Array.isArray(data)? data : [];
    activeIndex=0; arrived=false;
    renderArrows(); updateHUD(undefined);
  }
  function onMsg(ev){ try{ const p=JSON.parse(ev.data); if(p?.type==='anchors') setAnchors(p.data); }catch{} }
  document.addEventListener('message', onMsg); window.addEventListener('message', onMsg);

  // GPS
  function startGPS(){
    try{
      navigator.geolocation.getCurrentPosition(()=>{},()=>{}, {enableHighAccuracy:true, timeout:10000, maximumAge:1000});
      navigator.geolocation.watchPosition(pos=>{
        here={lat:pos.coords.latitude, lng:pos.coords.longitude};
        if(anchors.length && !arrived){
          const target=anchors[activeIndex];
          const dist=dMeters(here,target);
          updateHUD(dist);
          if (activeIndex < anchors.length-1 && dist <= 8){
            activeIndex+=1; renderArrows(); updateHUD(dMeters(here, anchors[activeIndex]));
          } else if (activeIndex===anchors.length-1 && dist<=25 && !arrived){
            showArrival();
          }
        }
      }, ()=>{}, {enableHighAccuracy:true, timeout:10000, maximumAge:1000, distanceFilter:1});
    }catch{}
  }

  window.addEventListener('load', ()=>{
    startGPS();
  });
})();
</script>
</body>
</html>
