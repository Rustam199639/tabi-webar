<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>TABI AR — Big Bright Arrows Everywhere</title>

<!-- A-Frame -->
<script src="https://aframe.io/releases/1.4.2/aframe.min.js" crossorigin="anonymous"></script>

<script>
  // Bind AR.js to A-Frame’s THREE and polyfill Math bits AR.js expects
  (function shimTHREE(){
    function apply(){
      try{
        var A = window.AFRAME; if(!A||!A.THREE) return false;
        if(!window.THREE) window.THREE = A.THREE;
        var T = window.THREE;
        if(!T.Math) T.Math = {};
        var MU = T.MathUtils || A.THREE.MathUtils;
        T.Math.degToRad = T.Math.degToRad || ((d)=>d*Math.PI/180);
        T.Math.radToDeg = T.Math.radToDeg || ((r)=>r*180/Math.PI);
        T.Math.clamp    = T.Math.clamp    || ((x,a,b)=>Math.min(Math.max(x,a),b));
        if(!T.PlaneBufferGeometry && T.PlaneGeometry) T.PlaneBufferGeometry = T.PlaneGeometry;
        console.log('[OK] [BOOT] THREE shim applied', {hasMath:!!T.Math, hasUtils:!!MU});
        return true;
      }catch(e){ return false; }
    }
    if(!apply()){ let n=0; const id=setInterval(()=>{ if(apply()||++n>100) clearInterval(id); },50); }
  })();

  // A-Frame helper: force objects to render on top and never cull
  if (window.AFRAME) {
    AFRAME.registerComponent('always-on-top', {
      tick(){ this.el.object3D.traverse(o=>{
        o.renderOrder = 9999;
        if (o.material){ o.material.depthTest=false; o.material.depthWrite=false; o.material.needsUpdate=true; }
        o.frustumCulled = false;
      });}
    });
  }
</script>

<!-- AR.js (A-Frame build) -->
<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.4/aframe/build/aframe-ar.js" crossorigin="anonymous"></script>

<style>
  html,body{margin:0;padding:0;overflow:hidden;background:#000;}
  /* Keep canvas above native layers */
  a-scene, .a-canvas, canvas{
    position:fixed!important; inset:0!important;
    width:100vw!important; height:100vh!important;
    z-index:1000000!important; display:block!important;
  }
  .hud{
    position:fixed; top:8px; left:8px; right:8px; z-index:2147483647;
    padding:8px 10px; background:rgba(0,0,0,.7); color:#fff;
    border-radius:12px; font:13px/18px system-ui; white-space:pre-line;
  }
</style>
</head>
<body>
<div id="hud" class="hud">Loading…</div>

<a-scene
  vr-mode-ui="enabled:false"
  renderer="alpha:false; antialias:true; sortObjects:true; physicallyCorrectLights:false; preserveDrawingBuffer:true"
  embedded
  arjs="sourceType: webcam; videoTexture: true; trackingMethod: best; debugUIEnabled: false"
>
  <!-- NON-projected GPS components: most broadly compatible -->
  <a-camera gps-camera rotation-reader camera="near:0.01; far:200000"></a-camera>

  <a-entity id="layer-arrows"></a-entity>
  <a-entity id="layer-arrival"></a-entity>

  <!-- local sanity markers so you always see *something* -->
  <a-plane position="0 1.5 -2" rotation="-10 0 0" width="2.6" height="1.2"
           material="shader:flat; color:#ff00ff; opacity:0.95; transparent:true"
           always-on-top></a-plane>
  <a-ring position="0 0 -3" rotation="-90 0 0" radius-inner="0.45" radius-outer="0.7"
          material="shader:flat; color:#ffffff; opacity:0.95; transparent:true"
          always-on-top></a-ring>
</a-scene>

<script>
(function(){
  // ======= CONFIG =======
  const CONFIG = {
    arrowsEnabled: true,
    // Show ONLY one arrow: the closest anchor within this radius
    onlyClosestWithinM: 50,     // ← 50 m visibility window
    useActiveIndex: false,      // true = show only the "next" (activeIndex) if within 50 m
    maxRenderDistanceM: 500,    // keep for safety, not used much now
    hideARVideo: true,

    // look & feel
    arrowColor: '#2aa8ff',
    arrowOpacity: 0.95
  };


  // ======= Helpers =======
  const hud = document.getElementById('hud');
  const arrowsLayer = document.getElementById('layer-arrows');
  const arrivalLayer = document.getElementById('layer-arrival');

  const toRad = d => d*Math.PI/180;
  function dMeters(a,b){
    const R=6371000, dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng), la1=toRad(a.lat), la2=toRad(b.lat);
    const h=Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLng/2)**2;
    return 2*R*Math.atan2(Math.sqrt(h), Math.sqrt(1-h));
  }
  function clear(el){ while(el.firstChild) el.removeChild(el.firstChild); }
  function placeAtLatLng(node, lat, lng){ node.setAttribute('gps-entity-place',`latitude:${lat}; longitude:${lng}`); }

  function makeArrow(yawDeg, scaleVal){
    const wrap=document.createElement('a-entity');
    wrap.setAttribute('rotation',`0 ${yawDeg||0} 0`);
    wrap.setAttribute('position','0 1.2 0');           // low in view
    wrap.setAttribute('scale', `${scaleVal} ${scaleVal} ${scaleVal}`);
    wrap.setAttribute('always-on-top','');

    // ~40 cm tall arrow before scaling
    const shaft=document.createElement('a-cylinder');
    shaft.setAttribute('height','0.28');               // 28 cm
    shaft.setAttribute('radius','0.02');               // 2 cm
    shaft.setAttribute('position','0 0.16 0');
    shaft.setAttribute('material',`shader:flat; color:${CONFIG.arrowColor}; opacity:${CONFIG.arrowOpacity}; transparent:true`);

    const head=document.createElement('a-cone');
    head.setAttribute('height','0.14');                // 14 cm
    head.setAttribute('radius-bottom','0.07');         // 7 cm
    head.setAttribute('radius-top','0.003');
    head.setAttribute('position','0 0.33 0');
    head.setAttribute('material',`shader:flat; color:${CONFIG.arrowColor}; opacity:${CONFIG.arrowOpacity}; transparent:true`);

    wrap.appendChild(shaft); wrap.appendChild(head);
    return wrap;
  }



  // ======= State =======
  let anchors=[]; let activeIndex=0; let arrived=false; let here=null; let originReady=false;

  // ======= HUD =======
  function updateHUD(dist){
    if (!anchors.length){ hud.textContent='Waiting for anchors…'; return; }
    if (arrived){ hud.textContent='Arrived — look around for the destination.'; return; }
    const next=anchors[activeIndex];
    const label=`${activeIndex+1}/${anchors.length}`;
    const dt=(typeof dist==='number')?`${Math.round(Math.max(0,dist))} m`:'…';
    hud.textContent=`Next: ${label} — ${dt}${next?`\n(${next.lat.toFixed(5)}, ${next.lng.toFixed(5)})`:''}`;
    console.log('[INFO] HUD', {activeIndex, dist:dt});
  }

  function scaleForDistance(distM){
    if (typeof CONFIG.fixedScale === 'number') return CONFIG.fixedScale; // respect fixed size
    const min=0.7, max=1.6, span=80;          // gentle growth with distance
    const d = Math.max(0, Math.min(span, distM||0));
    return min + (max-min)*(d/span);
  }


  // ======= Render =======
  function renderArrows(){
  console.log('[INFO] RENDER begin', {activeIndex, total:anchors.length, originReady});
  clear(arrivalLayer); clear(arrowsLayer);
  if (!CONFIG.arrowsEnabled) return;
  if (!anchors.length || arrived) return;

  // Need current location to decide visibility
  if (!here){ console.log('[INFO] no GPS yet — nothing to render'); return; }

  // Build candidate list with distances
  const withDist = anchors.map((a,i)=>({ i, a, dist: dMeters(here, a) }));

  // Keep only anchors within the 50 m window
  let candidates = withDist.filter(o => o.dist <= CONFIG.onlyClosestWithinM);

  // Option: show only the "next" waypoint if it's within 50 m
  if (CONFIG.useActiveIndex){
    const pick = withDist[activeIndex];
    candidates = (pick && pick.dist <= CONFIG.onlyClosestWithinM) ? [pick] : [];
  }else{
    // Otherwise, pick the nearest within 50 m
    if (candidates.length){
      candidates.sort((x,y)=>x.dist-y.dist);
      candidates = [candidates[0]];
    }
  }

  console.log('[INFO] RENDER will show', {count:candidates.length, indices:candidates.map(c=>c.i)});
  candidates.forEach(({i,a,dist})=>{
    const node = document.createElement('a-entity');
    placeAtLatLng(node, a.lat, a.lng);
    node.appendChild(makeArrow(a.yaw, scaleForDistance(dist)));
    arrowsLayer.appendChild(node);
  });

  console.log('[INFO] RENDER end', {children:arrowsLayer.children.length});
}


  function showArrival(){
    arrived=true; clear(arrowsLayer); clear(arrivalLayer);
    const last=anchors[anchors.length-1]; if(!last) return;
    const w=document.createElement('a-entity'); placeAtLatLng(w,last.lat,last.lng);
    const r=document.createElement('a-ring'); r.setAttribute('radius-inner','2'); r.setAttribute('radius-outer','2.6'); r.setAttribute('rotation','-90 0 0'); r.setAttribute('position','0 0.2 0');
    r.setAttribute('material','shader:flat; color:#10b981; opacity:1; transparent:true'); r.setAttribute('always-on-top','');
    w.appendChild(r); arrivalLayer.appendChild(w);
    hud.textContent='Arrived — look around for the destination.';
  }

  // ======= RN bridge =======
  function setAnchors(data){
    anchors = Array.isArray(data)? data : [];
    activeIndex=0; arrived=false;
    console.log('[INFO] ANCHORS received', {count:anchors.length, first:anchors[0], last:anchors[anchors.length-1]});
    renderArrows(); updateHUD(undefined);
  }
  function onMsg(ev){ try{ const p=JSON.parse(ev.data); if(p?.type==='anchors') setAnchors(p.data); }catch{} }
  document.addEventListener('message', onMsg); window.addEventListener('message', onMsg);

  // ======= GPS & origin =======
  const camEl = document.querySelector('[gps-camera]');
  camEl?.addEventListener('gps-camera-origin-coord', e => { originReady=true; console.log('[INFO] origin ready', e.detail); });

  function startGPS(){
    try{
      navigator.geolocation.getCurrentPosition(
        pos=>{ here={lat:pos.coords.latitude, lng:pos.coords.longitude}; console.log('[INFO] getCurrentPosition', here); },
        err=>{ console.warn('[WARN] getCurrentPosition failed', err); },
        {enableHighAccuracy:true, timeout:10000, maximumAge:1000}
      );
      navigator.geolocation.watchPosition(pos=>{
        here={lat:pos.coords.latitude, lng:pos.coords.longitude};
        console.log('[INFO] watchPosition', {lat:here.lat, lng:here.lng, acc:pos.coords.accuracy});
        if(anchors.length && !arrived){
          const target=anchors[activeIndex];
          const dist=dMeters(here,target);
          updateHUD(dist);
          if (activeIndex < anchors.length-1 && dist <= 8){
            activeIndex+=1; renderArrows(); updateHUD(dMeters(here, anchors[activeIndex]));
          } else if (activeIndex===anchors.length-1 && dist<=25 && !arrived){
            showArrival();
          }
        }
      }, err=>console.warn('[WARN] watchPosition failed', err),
      {enableHighAccuracy:true, timeout:10000, maximumAge:1000, distanceFilter:1});
    }catch(e){ console.warn('[WARN] GPS start failed', e); }
  }

  // ======= Layer enforcement (keeps canvas on top, hides video if desired) =======
  function enforceLayers(){
    try{
      const canv = document.querySelector('canvas.a-canvas');
      const videos = document.querySelectorAll('video');
      console.log('[INFO] Layer check', {hasCanvas:!!canv, videoCount:videos.length});
      if (canv){
        const st = getComputedStyle(canv);
        console.log('[INFO] Canvas style', {w:st.width,h:st.height,display:st.display,position:st.position,z:st.zIndex});
        canv.style.position='fixed'; canv.style.inset='0'; canv.style.zIndex='1000000'; canv.style.display='block';
      }
      if (CONFIG.hideARVideo && videos.length){
        videos.forEach((v,i)=>{ v.style.visibility='hidden'; v.style.display='none'; console.log('[INFO] Hid AR.js video', {i, id:v.id}); });
      }
    }catch{}
  }
  setInterval(enforceLayers, 1500);

  // ======= Boot =======
  window.addEventListener('load', ()=>{
    console.log('[INFO] window load');
    startGPS();
  });
})();
</script>
</body>
</html>
