<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>TABI AR — Turn-by-Turn</title>

<!-- A-Frame -->
<script src="https://aframe.io/releases/1.4.2/aframe.min.js" crossorigin="anonymous"></script>

<script>
  // Bind AR.js to A-Frame’s THREE and polyfill Math bits AR.js expects
  (function shimTHREE(){
    function apply(){
      try{
        var A = window.AFRAME; if(!A||!A.THREE) return false;
        if(!window.THREE) window.THREE = A.THREE;
        var T = window.THREE;
        if(!T.Math) T.Math = {};
        var MU = T.MathUtils || A.THREE.MathUtils;
        T.Math.degToRad = T.Math.degToRad || (d=>d*Math.PI/180);
        T.Math.radToDeg = T.Math.radToDeg || (r=>r*180/Math.PI);
        T.Math.clamp    = T.Math.clamp    || ((x,a,b)=>Math.min(Math.max(x,a),b));
        if(!T.PlaneBufferGeometry && T.PlaneGeometry) T.PlaneBufferGeometry = T.PlaneGeometry;
        console.log('[OK] [BOOT] THREE shim applied', {hasMath:!!T.Math, hasUtils:!!MU});
        return true;
      }catch(e){ return false; }
    }
    if(!apply()){ let n=0; const id=setInterval(()=>{ if(apply()||++n>100) clearInterval(id); },50); }
  })();

  // A-Frame helper: force objects to render on top and never cull
  if (window.AFRAME) {
    AFRAME.registerComponent('always-on-top', {
      tick(){ this.el.object3D.traverse(o=>{
        o.renderOrder = 9999;
        if (o.material){ o.material.depthTest=false; o.material.depthWrite=false; o.material.needsUpdate=true; }
        o.frustumCulled = false;
      });}
    });
  }
</script>

<!-- AR.js (A-Frame build) -->
<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.4/aframe/build/aframe-ar.js" crossorigin="anonymous"></script>

<style>
  html,body{margin:0;padding:0;overflow:hidden;background:#000;}
  a-scene, .a-canvas, canvas{
    position:fixed!important; inset:0!important;
    width:100vw!important; height:100vh!important;
    z-index:1000000!important; display:block!important;
  }
  .hud{
    position:fixed; top:8px; left:8px; right:8px; z-index:2147483647;
    padding:8px 10px; background:rgba(0,0,0,.7); color:#fff;
    border-radius:12px; font:13px/18px system-ui; white-space:pre-line;
  }

  /* Bottom nav panel */
  .nav{
    position:fixed; left:10px; right:10px; bottom:10px; z-index:2147483647;
    background:rgba(0,0,0,.66); color:#fff; border-radius:14px; padding:10px;
    font:13px/18px system-ui; backdrop-filter:saturate(120%) blur(6px);
  }
  .nav-top{ display:flex; gap:8px; margin-bottom:8px; }
  .btn{
    appearance:none; border:0; padding:8px 10px; border-radius:10px;
    background:#2a2a2a; color:#fff; font-weight:600;
  }
  .btn-primary{ background:#1a73e8; }
  .nav-main{ display:flex; align-items:center; gap:12px; }
  .dial{ width:64px; height:64px; border-radius:50%; background:#111; display:grid; place-items:center; }
  #navArrow{ width:52px; height:52px; transform-origin:50% 50%; }
  #navArrow polygon{ fill:#1a73e8; }
  .stats{ display:flex; flex-direction:column; gap:2px; }
  .stats .big{ font-weight:800; font-size:20px; line-height:22px; }
  .stats .small{ opacity:.8; }
</style>
</head>
<body>
<div id="hud" class="hud">Loading…</div>

<!-- Bottom nav -->
<div id="nav" class="nav">
  <div class="nav-top">
    <button id="btnMaps" class="btn">Google Maps</button>
    <button id="btnCal" class="btn btn-primary">Calibrate</button>
  </div>
  <div class="nav-main">
    <div class="dial">
      <svg id="navArrow" viewBox="0 0 100 100" aria-label="direction arrow">
        <polygon points="50,8 68,60 58,60 58,92 42,92 42,60 32,60"/>
      </svg>
    </div>
    <div class="stats">
      <div id="navDist" class="big">— m</div>
      <div id="navText" class="small">Point the arrow to walk</div>
    </div>
  </div>
</div>

<a-scene
  vr-mode-ui="enabled:false"
  renderer="alpha:false; antialias:true; sortObjects:true; physicallyCorrectLights:false"
  embedded
  arjs="sourceType: webcam; videoTexture: true; trackingMethod: best; debugUIEnabled: false"
>
  <a-camera gps-camera rotation-reader camera="near:0.01; far:200000"></a-camera>

  <!-- Wrap everything we place so we can rotate the whole world for calibration -->
  <a-entity id="world-root">
    <a-entity id="layer-arrows"></a-entity>
    <a-entity id="layer-arrival"></a-entity>
  </a-entity>
</a-scene>

<script>
(function(){
  // ======= CONFIG =======
  const CONFIG = {
    arrowsEnabled: true,        // master switch
    maxVisibleDistM: 50,        // show the next arrow only if within 50 m
    minArriveStepM: 8,          // move to next anchor when you're within 8 m
    arrivalShowM: 25,           // show arrival ring when within 25 m of final anchor
    hideARVideo: true
  };

  // ======= DOM refs =======
  const hud = document.getElementById('hud');
  const arrowsLayer = document.getElementById('layer-arrows');
  const arrivalLayer = document.getElementById('layer-arrival');
  const worldRoot = document.getElementById('world-root');
  const navDistEl   = document.getElementById('navDist');
  const navTextEl   = document.getElementById('navText');
  const navArrowSVG = document.getElementById('navArrow');

  // ======= Math helpers =======
  const toRad = d => d*Math.PI/180;
  const toDeg = r => r*180/Math.PI;
  const wrapDeg = d => ((d%360)+360)%360;

  function dMeters(a,b){
    const R=6371000, dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng), la1=toRad(a.lat), la2=toRad(b.lat);
    const h=Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLng/2)**2;
    return 2*R*Math.atan2(Math.sqrt(h), Math.sqrt(1-h));
  }
  function bearingTo(a,b){
    const φ1=toRad(a.lat), φ2=toRad(b.lat), Δλ=toRad(b.lng-a.lng);
    const y = Math.sin(Δλ)*Math.cos(φ2);
    const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(Δλ);
    return wrapDeg(toDeg(Math.atan2(y,x))); // 0..360 (0=N)
  }
  function clear(el){ while(el.firstChild) el.removeChild(el.firstChild); }
  function placeAtLatLng(node, lat, lng){ node.setAttribute('gps-entity-place',`latitude:${lat}; longitude:${lng}`); }

  // ======= Arrow factory (SMALL + flat shaded) =======
  function makeArrow(yawDeg, scaleVal){
    const wrap=document.createElement('a-entity');
    wrap.setAttribute('rotation',`0 ${yawDeg||0} 0`);
    wrap.setAttribute('position','0 0 0');
    wrap.setAttribute('scale', `${scaleVal} ${scaleVal} ${scaleVal}`);
    wrap.setAttribute('always-on-top','');

    // Small geometry: ~1.35 m tall at scale=1
    const shaft=document.createElement('a-cylinder');
    shaft.setAttribute('height','0.9'); shaft.setAttribute('radius','0.06'); shaft.setAttribute('position','0 0.55 0');
    shaft.setAttribute('material','shader:flat; color:#00bcd4; opacity:0.95; transparent:true');

    const head=document.createElement('a-cone');
    head.setAttribute('height','0.45'); head.setAttribute('radius-bottom','0.18'); head.setAttribute('radius-top','0.01'); head.setAttribute('position','0 1.1 0');
    head.setAttribute('material','shader:flat; color:#00bcd4; opacity:0.95; transparent:true');

    wrap.appendChild(shaft); wrap.appendChild(head);
    return wrap;
  }

  // ======= State =======
  let anchors=[]; let activeIndex=0; let arrived=false; let here=null; let originReady=false;
  let worldBiasDeg = 0; // calibration rotation we apply to world-root

  // ======= HUD =======
  function updateHUD(dist){
    if (!anchors.length){ hud.textContent='Waiting for anchors…'; return; }
    if (arrived){ hud.textContent='Arrived — look around for the destination.'; return; }
    const next=anchors[activeIndex];
    const label=`${activeIndex+1}/${anchors.length}`;
    const dt=(typeof dist==='number')?`${Math.round(Math.max(0,dist))} m`:'…';
    hud.textContent=`Next: ${label} — ${dt}${next?`\n(${next.lat.toFixed(5)}, ${next.lng.toFixed(5)})`:''}`;
    console.log('[INFO] HUD', {activeIndex, dist:dt});
  }

  // Scale rule: bigger when closer (0..50 m -> 1.4..0.6)
  function scaleForDistance(distM){
    if (distM == null) return 1.0;
    const d = Math.max(0, Math.min(50, distM));
    const sClose=1.4, sFar=0.6;
    const s = sFar + (sClose - sFar) * (1 - d/50);
    return s;
  }

  // ======= Heading & calibration =======
  const camEl = document.querySelector('[gps-camera]');

  function getHeadingDeg(){
    try{
      const comp = camEl?.components?.['gps-camera'];
      if (comp && typeof comp.heading === 'number' && !Number.isNaN(comp.heading)) {
        return wrapDeg(comp.heading); // 0..360, 0=N
      }
    }catch{}
    const y = camEl?.object3D?.rotation?.y || 0; // fallback
    return wrapDeg(-toDeg(y));
  }
  function applyWorldBias(){ worldRoot?.setAttribute('rotation', `0 ${worldBiasDeg} 0`); }
  function calibrateToTarget(){
    if (!here || !anchors.length) return;
    const target = anchors[activeIndex] || anchors[0];
    const brg = bearingTo(here, target);
    const hdg = getHeadingDeg();
    const delta = brg - hdg;
    worldBiasDeg = wrapDeg(worldBiasDeg - delta);
    applyWorldBias();
    updateNavUI();
  }
  function openGoogleMaps(){
    if (!anchors.length) return;
    const t = anchors[activeIndex] || anchors[0];
    const url = `https://www.google.com/maps/dir/?api=1&destination=${t.lat},${t.lng}&travelmode=walking`;
    window.location.href = url;
  }
  document.getElementById('btnCal').addEventListener('click', calibrateToTarget);
  document.getElementById('btnMaps').addEventListener('click', openGoogleMaps);

  // Bottom panel arrow (UI) – rotate to show turn direction
  function updateNavUI(){
    let distStr = '—';
    let turn = 0;

    if (here && anchors.length){
      const target = anchors[activeIndex] || anchors[0];
      const dist = dMeters(here, target);
      distStr = `${Math.round(dist)} m`;

      const brg = bearingTo(here, target);
      const hdg = getHeadingDeg();
      turn = wrapDeg(brg - hdg - worldBiasDeg);
    }

    navDistEl.textContent = distStr;
    navArrowSVG.style.transform = `rotate(${turn}deg)`;
    navTextEl.textContent = (turn>=350 || turn<=10) ? 'Go straight' :
                            (turn<180 ? `Turn right ${Math.round(turn)}°` :
                                        `Turn left ${Math.round(360-turn)}°`);
  }

  // ======= Render =======
  function renderArrows(){
    console.log('[INFO] RENDER begin', {activeIndex, total:anchors.length, originReady});
    clear(arrivalLayer); clear(arrowsLayer);
    if(!anchors.length || arrived || !CONFIG.arrowsEnabled) return;

    // We show ONLY the next anchor, and ONLY if it's within 50 m
    const target = anchors[activeIndex];
    if (!target) return;

    let dist = null;
    if (here) dist = dMeters(here, target);
    if (dist !== null && dist > CONFIG.maxVisibleDistM) {
      console.log('[INFO] Arrow hidden (too far)', {dist});
      return; // nothing rendered when > 50 m away
    }

    const n = document.createElement('a-entity');
    placeAtLatLng(n, target.lat, target.lng);

    // Orientation: point from your position toward the target (fallback to path forward)
    let yawDeg = 0;
    if (here) yawDeg = bearingTo(here, target);
    else if (activeIndex < anchors.length-1) yawDeg = bearingTo(target, anchors[activeIndex+1]);

    const sc = scaleForDistance(dist);
    n.appendChild(makeArrow(yawDeg, sc));
    arrowsLayer.appendChild(n);

    console.log('[INFO] RENDER end', {children:arrowsLayer.children.length});
  }

  function showArrival(){
    arrived=true; clear(arrowsLayer); clear(arrivalLayer);
    const last=anchors[anchors.length-1]; if(!last) return;
    const w=document.createElement('a-entity'); placeAtLatLng(w,last.lat,last.lng);
    const r=document.createElement('a-ring'); r.setAttribute('radius-inner','2'); r.setAttribute('radius-outer','2.6'); r.setAttribute('rotation','-90 0 0'); r.setAttribute('position','0 0.2 0');
    r.setAttribute('material','shader:flat; color:#10b981; opacity:1; transparent:true'); r.setAttribute('always-on-top','');
    w.appendChild(r); arrivalLayer.appendChild(w);
    hud.textContent='Arrived — look around for the destination.';
  }

  // ======= RN bridge =======
  function setAnchors(data){
    anchors = Array.isArray(data)? data : [];
    activeIndex=0; arrived=false;
    console.log('[INFO] ANCHORS received', {count:anchors.length, first:anchors[0], last:anchors[anchors.length-1]});
    renderArrows(); updateHUD(undefined); updateNavUI();
  }
  function onMsg(ev){ try{ const p=JSON.parse(ev.data); if(p?.type==='anchors') setAnchors(p.data); }catch{} }
  document.addEventListener('message', onMsg); window.addEventListener('message', onMsg);

  // ======= GPS & origin =======
  camEl?.addEventListener('gps-camera-origin-coord', e => { originReady=true; console.log('[INFO] origin ready', e.detail); });

  function startGPS(){
    try{
      navigator.geolocation.getCurrentPosition(
        pos=>{ here={lat:pos.coords.latitude, lng:pos.coords.longitude}; console.log('[INFO] getCurrentPosition', here); },
        err=>{ console.warn('[WARN] getCurrentPosition failed', err); },
        {enableHighAccuracy:true, timeout:10000, maximumAge:1000}
      );
      navigator.geolocation.watchPosition(pos=>{
        here={lat:pos.coords.latitude, lng:pos.coords.longitude};
        console.log('[INFO] watchPosition', {lat:here.lat, lng:here.lng, acc:pos.coords.accuracy});
        if(anchors.length && !arrived){
          const target=anchors[activeIndex];
          const dist=dMeters(here,target);
          updateHUD(dist);

          // Step forward when close; finish at the end
          if (activeIndex < anchors.length-1 && dist <= CONFIG.minArriveStepM){
            activeIndex+=1; renderArrows(); updateHUD(dMeters(here, anchors[activeIndex]));
          } else if (activeIndex===anchors.length-1 && dist<=CONFIG.arrivalShowM && !arrived){
            showArrival();
          } else {
            // distance changed; rescale arrow if visible
            renderArrows();
          }
        }
        updateNavUI();
      }, err=>console.warn('[WARN] watchPosition failed', err),
      {enableHighAccuracy:true, timeout:10000, maximumAge:1000, distanceFilter:1});
    }catch(e){ console.warn('[WARN] GPS start failed', e); }
  }

  // ======= Layer enforcement (keeps canvas on top, hides video if desired) =======
  function enforceLayers(){
    try{
      const canv = document.querySelector('canvas.a-canvas');
      const videos = document.querySelectorAll('video');
      console.log('[INFO] Layer check', {hasCanvas:!!canv, videoCount:videos.length});
      if (canv){
        const st = getComputedStyle(canv);
        console.log('[INFO] Canvas style', {w:st.width,h:st.height,display:st.display,position:st.position,z:st.zIndex});
        canv.style.position='fixed'; canv.style.inset='0'; canv.style.zIndex='1000000'; canv.style.display='block';
      }
      if (CONFIG.hideARVideo && videos.length){
        videos.forEach((v,i)=>{ v.style.visibility='hidden'; v.style.display='none'; console.log('[INFO] Hid AR.js video', {i, id:v.id}); });
      }
    }catch{}
  }
  setInterval(enforceLayers, 1500);

  // ======= Boot =======
  window.addEventListener('load', ()=>{
    console.log('[INFO] window load');
    startGPS();
    setInterval(updateNavUI, 250); // smooth heading updates
  });
})();
</script>
</body>
</html>
