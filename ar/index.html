<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>TABI Agent AR Arrows</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js" crossorigin="anonymous"></script>

  <!-- Robust THREE shim so AR.js (built for older THREE) works with A-Frame 1.4.x -->
  <script>
    (function fixThreeForARJS(){
      function apply(){
        try{
          var A = window.AFRAME;
          if (!A || !A.THREE) return false;
          if (!window.THREE) window.THREE = A.THREE;       // AR.js reads from window.THREE

          var T = window.THREE;
          if (!T.Math) T.Math = {};
          var MU = T.MathUtils || (A.THREE && A.THREE.MathUtils);
          if (!T.Math.degToRad) T.Math.degToRad = MU && MU.degToRad ? MU.degToRad : function(d){ return d * Math.PI / 180; };
          if (!T.Math.radToDeg) T.Math.radToDeg = MU && MU.radToDeg ? MU.radToDeg : function(r){ return r * 180 / Math.PI; };
          if (!T.Math.clamp)    T.Math.clamp    = MU && MU.clamp    ? MU.clamp    : function(x,min,max){ return Math.min(Math.max(x,min),max); };
          if (!T.PlaneBufferGeometry && T.PlaneGeometry) T.PlaneBufferGeometry = T.PlaneGeometry; // quiet alias
          return true;
        }catch(e){ return false; }
      }
      if (!apply()){
        var tries = 0, id = setInterval(function(){ if (apply() || ++tries > 80) clearInterval(id); }, 50);
        document.addEventListener('DOMContentLoaded', apply, { once: true });
      }
    })();
  </script>

  <!-- AR.js (A-Frame build) -->
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.4/aframe/build/aframe-ar.js" crossorigin="anonymous"></script>

  <!-- No-op rotation-reader to avoid missing component errors -->
  <script>
    if (window.AFRAME && !AFRAME.components['rotation-reader']) {
      AFRAME.registerComponent('rotation-reader', { schema:{}, tick:function(){} });
    }
    // Always-on-top + no-cull helpers
    AFRAME.registerComponent('always-on-top', {
      init(){ this.el.object3D.traverse(o=>{
        o.renderOrder = 9999;
        if (o.material){ o.material.depthTest = false; o.material.depthWrite = false; o.material.needsUpdate = true; }
      }); },
      tick(){ this.el.object3D.traverse(o=>{
        o.renderOrder = 9999;
        if (o.material){ o.material.depthTest = false; o.material.depthWrite = false; }
        o.frustumCulled = false;
      }); }
    });
    AFRAME.registerComponent('nocull', {
      tick(){ this.el.object3D.traverse(o=>{ o.frustumCulled = false; }); }
    });
  </script>

  <style>
    html,body{margin:0;padding:0;overflow:hidden;background:#000;font-family:system-ui,-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif}
    .hud{
      position:fixed;top:8px;left:8px;right:8px;
      padding:8px 10px;background:rgba(0,0,0,.65);color:#fff;
      font-size:13px;line-height:18px;border-radius:12px;white-space:pre-line;
      z-index:999999; pointer-events:none;
    }
  </style>
</head>
<body>
  <div id="hud" class="hud">Loading… allow camera & motion when prompted.</div>

  <a-scene
    vr-mode-ui="enabled:false"
    renderer="alpha:true; antialias:true; physicallyCorrectLights:true; logarithmicDepthBuffer:true"
    embedded
    arjs="sourceType: webcam; videoTexture: true; trackingMethod: best; debugUIEnabled: false"
  >
    <!-- Bright basic lights -->
    <a-entity light="type: ambient; intensity: 1.2"></a-entity>
    <a-entity light="type: directional; intensity: 0.9" position="0 2 1"></a-entity>

    <!-- Use projected camera to match projected entities; extend far plane a lot -->
    <a-camera gps-projected-camera rotation-reader camera="near:0.01; far:200000"></a-camera>

    <a-entity id="layer-arrows"></a-entity>
    <a-entity id="layer-arrival"></a-entity>

    <!-- Local debug: should always be visible 2m ahead -->
    <a-box position="0 1.6 -2" depth="0.3" height="0.3" width="0.3"
           material="shader:standard; color:#4ADE80; metalness:0; roughness:0.4; opacity:0.9; transparent:true"
           always-on-top nocull></a-box>

    <!-- Debug: big white ring 3 m straight ahead -->
    <a-ring id="debug-forward" position="0 0 -3" rotation="-90 0 0"
            radius-inner="0.4" radius-outer="0.55"
            material="shader:standard; color:#ffffff; metalness:0; roughness:0.5; opacity:0.95; transparent:true"
            always-on-top nocull></a-ring>
  </a-scene>

  <script>
  (function(){
    // Silence generic cross-origin errors to keep console actionable
    window.addEventListener('error', e => {
      if (e.message === 'Script error.' && !e.filename) { e.preventDefault(); return true; }
    });

    const hud = document.getElementById('hud');
    const arrowsLayer = document.getElementById('layer-arrows');
    const arrivalLayer = document.getElementById('layer-arrival');
    const cameraEl = document.querySelector('[gps-projected-camera]');

    const log=(...a)=>{try{console.log(...a)}catch{}};
    const warn=(...a)=>{try{console.warn(...a)}catch{}};
    const send=(m)=>{try{window.ReactNativeWebView?.postMessage(JSON.stringify(m))}catch{}};

    log('[AR] DOM ok. useProjected = true');

    // Math helpers
    const toRad = d => d*Math.PI/180;
    function dMeters(a,b){
      const R=6371000, dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng), lat1=toRad(a.lat), lat2=toRad(b.lat);
      const hav = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLng/2)**2;
      return 2*R*Math.atan2(Math.sqrt(hav), Math.sqrt(1-hav));
    }

    // DOM helpers
    function clear(el){ if (!el) return; while(el.firstChild) el.removeChild(el.firstChild); }
    function placeAtLatLng(node, lat, lng){
      node.setAttribute('gps-projected-entity-place', `latitude: ${lat}; longitude: ${lng}`);
    }

    // Visibility helpers
    function forceTop(el){ try{
      el.setAttribute('always-on-top',''); el.setAttribute('nocull','');
    }catch{} }

    // Make arrows very obvious
    function scaleFor(distance){
      const s = Math.max(24, Math.min(60, 18 + (distance/3))); // BIGGER minimum now
      return `${s} ${s} ${s}`;
    }

    // Directional arrow (bright + always-on-top)
    function makeArrow(yawDeg, approxDistance){
      const wrap = document.createElement('a-entity');
      wrap.setAttribute('rotation', `0 ${yawDeg} 0`);
      wrap.setAttribute('position', '0 2 0'); // ~2m above ground so it's in the FOV
      wrap.setAttribute('scale', scaleFor(approxDistance || 30));
      forceTop(wrap);

      const shaft = document.createElement('a-cylinder');
      shaft.setAttribute('height','6.0');
      shaft.setAttribute('radius','0.35');
      shaft.setAttribute('position','0 3 0');
      shaft.setAttribute('material','shader:standard; color:#00E0FF; metalness:0; roughness:0.3; opacity:1; transparent:true');
      // depth flags on materials (belt & suspenders)
      shaft.addEventListener('loaded', ()=> {
        const m = shaft.getObject3D('mesh')?.material; if (m){ m.depthTest=false; m.depthWrite=false; m.needsUpdate=true; }
      });

      const head = document.createElement('a-cone');
      head.setAttribute('height','2.6');
      head.setAttribute('radius-bottom','1.1');
      head.setAttribute('radius-top','0.01');
      head.setAttribute('position','0 5.5 0');
      head.setAttribute('material','shader:standard; color:#00E0FF; metalness:0; roughness:0.25; opacity:1; transparent:true');
      head.addEventListener('loaded', ()=> {
        const m = head.getObject3D('mesh')?.material; if (m){ m.depthTest=false; m.depthWrite=false; m.needsUpdate=true; }
      });

      wrap.appendChild(shaft);
      wrap.appendChild(head);
      return wrap;
    }

    function makeDebugBillboard(txt='●', color='#ff0000'){
      const e = document.createElement('a-entity');
      e.setAttribute('position','0 2 0');
      e.setAttribute('text',`value:${txt}; color:${color}; align:center; width:6;`);
      e.setAttribute('look-at','[gps-projected-camera]');
      forceTop(e);
      return e;
    }

    // State
    let anchors = [];       // [{lat,lng,yaw}]
    let activeIndex = 0;
    let arrived = false;
    let here = null;        // {lat,lng} from watchPosition

    function updateHUD(dist){
      if (!anchors.length){ hud.textContent='Waiting for anchors…'; return; }
      if (arrived){ hud.textContent='Arrived — look around for the destination.'; return; }
      const next = anchors[activeIndex];
      const label = `${activeIndex+1}/${anchors.length}`;
      const dt = (typeof dist==='number') ? `${Math.max(0,Math.round(dist))} m` : '…';
      hud.textContent = `Next: ${label} — ${dt}${next?`\n(${next.lat.toFixed(5)}, ${next.lng.toFixed(5)})`:''}`;
    }

    function renderArrows(){
      clear(arrivalLayer); clear(arrowsLayer);
      if (!anchors.length || arrived) return;

      const toShow = [activeIndex, activeIndex+1].filter(i => i < anchors.length);
      log('[AR] render arrows', toShow.length, 'active', activeIndex);
      send({ type:'arrows_rendered', count: toShow.length, active: activeIndex });

      toShow.forEach((idx,i) => {
        const a = anchors[idx];
        const node = document.createElement('a-entity');
        placeAtLatLng(node, a.lat, a.lng);
        forceTop(node);

        // obvious label + arrow
        node.appendChild(makeDebugBillboard(i===0 ? 'NEXT' : '→', i===0 ? '#ff4444' : '#ffaa00'));

        const approx = here ? dMeters(here, a) : 30;
        node.appendChild(makeArrow(a.yaw, approx));

        arrowsLayer.appendChild(node);
      });
    }

    function showArrival(){
      arrived = true;
      clear(arrowsLayer); clear(arrivalLayer);
      const last = anchors[anchors.length-1]; if (!last) return;

      const wrap = document.createElement('a-entity');
      placeAtLatLng(wrap, last.lat, last.lng);
      forceTop(wrap);

      const ring = document.createElement('a-ring');
      ring.setAttribute('radius-inner','2.0');
      ring.setAttribute('radius-outer','2.6');
      ring.setAttribute('rotation','-90 0 0');
      ring.setAttribute('position','0 0.2 0');
      ring.setAttribute('material','shader:standard; color:#10B981; metalness:0; roughness:0.5; opacity:1; transparent:true');
      ring.addEventListener('loaded', ()=> {
        const m = ring.getObject3D('mesh')?.material; if (m){ m.depthTest=false; m.depthWrite=false; m.needsUpdate=true; }
      });
      wrap.appendChild(ring);

      const txt = document.createElement('a-entity');
      txt.setAttribute('text','value:ARRIVED; color:#10B981; align:center; width:8;');
      txt.setAttribute('position','0 2 0');
      txt.setAttribute('look-at','[gps-projected-camera]');
      wrap.appendChild(txt);

      arrivalLayer.appendChild(wrap);
      hud.textContent = 'Arrived — look around for the destination.';
      send({ type:'arrived' });
    }

    function setAnchors(data){
      anchors = Array.isArray(data) ? data : [];
      activeIndex = 0; arrived = false;
      log('[AR] anchors received', anchors.length);
      send({ type:'anchors_received', count: anchors.length });
      renderArrows(); updateHUD(undefined);
    }

    function onMsg(ev){
      try{
        const p = JSON.parse(ev.data);
        if (p?.type === 'anchors') setAnchors(p.data);
      }catch(err){ warn('[AR] invalid message', err); }
    }
    document.addEventListener('message', onMsg);
    window.addEventListener('message', onMsg);

    // Live position for HUD + advancing logic
    let watchId = null;
    function startWatch(){
      if (watchId !== null) return;
      try{
        watchId = navigator.geolocation.watchPosition(
          pos => {
            here = { lat: pos.coords.latitude, lng: pos.coords.longitude };
            send({ type:'geo_ok', lat: here.lat, lng: here.lng });

            if (anchors.length && !arrived) {
              const target = anchors[activeIndex];
              const dist = dMeters(here, target);
              updateHUD(dist);

              // fat re-scale (just keep first group huge)
              try {
                const groups = arrowsLayer.children || [];
                for (let i=0;i<groups.length;i++){
                  const group = groups[i];
                  group.setAttribute('nocull','');
                  group.object3D.traverse(o=>{ o.frustumCulled=false; o.renderOrder=9999; });
                }
              } catch {}

              if (activeIndex < anchors.length-1 && dist <= 8){
                activeIndex += 1; renderArrows(); updateHUD(dMeters(here, anchors[activeIndex]));
                log('[AR] advance to', activeIndex); send({ type:'advance', idx: activeIndex });
              } else if (activeIndex === anchors.length-1 && dist <= 25 && !arrived){
                showArrival();
              }
            }
          },
          err => {
            warn('[AR] watchPosition error', err?.code, err?.message);
            send({ type:'geo_error', code:err?.code, message:err?.message });
          },
          { enableHighAccuracy:true, timeout:10000, maximumAge:1000, distanceFilter:1 }
        );
      }catch(e){ warn('[AR] watchPosition failed', e); }
    }

    window.addEventListener('load', function(){
      log('[AR] window load'); send({ type:'ready' });
      try{
        navigator.geolocation.getCurrentPosition(
          p => { log('[AR] getCurrentPosition ok', p?.coords?.latitude, p?.coords?.longitude); },
          e => { warn('[AR] getCurrentPosition error', e?.code, e?.message); },
          { enableHighAccuracy:true, timeout:10000, maximumAge:1000 }
        );
      }catch(e){ warn('[AR] geolocation call failed', e); }
      startWatch();
    });

    // Re-render on camera origin/update events if available
    ['gps-projected-camera-origin-coord','gps-camera-update-position'].forEach(evt=>{
      cameraEl && cameraEl.addEventListener(evt, () => { log('[AR] camera event:', evt); renderArrows(); });
    });
  })();
  </script>
</body>
</html>
